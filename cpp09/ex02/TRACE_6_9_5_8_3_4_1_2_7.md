# Ford-Johnson Algorithm Trace for Input: 6 9 5 8 3 4 1 2 7

## Initial Array
Input: [6, 9, 5, 8, 3, 4, 1, 2, 7]
Size: 9 elements (odd)

---

## Step 1: Handle Odd Number
Since we have 9 elements (odd), save the last element for later:
- **Leftover**: 7
- **Working Array**: [6, 9, 5, 8, 3, 4, 1, 2]

---

## Step 2: Create Pairs (Compare and Sort Within Pairs)
Pair up adjacent elements, keeping larger as 'a' and smaller as 'b':

| Pair | Compare | Result (b, a) |
|------|---------|---------------|
| 1    | 6 vs 9  | (6, 9)        |
| 2    | 5 vs 8  | (5, 8)        |
| 3    | 3 vs 4  | (3, 4)        |
| 4    | 1 vs 2  | (1, 2)        |

**Pairs**: [(6,9), (5,8), (3,4), (1,2)]

---

## Step 3: Extract 'a' Values (Larger Elements)
From each pair, extract the larger value (a):
- **a values**: [9, 8, 4, 2]

---

## Step 4: ðŸ“¥ RECURSION - Sort 'a' Values Using Ford-Johnson

### RECURSION LEVEL 1: Sort [9, 8, 4, 2]

#### R1.1: Create Pairs
- Compare 9 vs 8 â†’ (8, 9)
- Compare 4 vs 2 â†’ (2, 4)
- **Pairs**: [(8,9), (2,4)]

#### R1.2: Extract 'a' values
- **a values**: [9, 4]

#### R1.3: ðŸ“¥ RECURSION - Sort [9, 4]

##### RECURSION LEVEL 2: Sort [9, 4]

###### R2.1: Create Pairs (only 2 elements)
- Compare 9 vs 4 â†’ (4, 9)
- **Pairs**: [(4, 9)]

###### R2.2: Extract 'a' values
- **a values**: [9]

###### R2.3: Base Case
- Only 1 element, already sorted: [9]

###### R2.4: Build Main Chain
- S = [4] (first b)
- S = [4, 9] (add all a's)
- No more b values to insert
- **Return [4, 9]**

##### ðŸ“¤ RECURSION RETURNED: [4, 9]

#### R1.4: Reorder pairs by sorted 'a' values
- Original: [(8,9), (2,4)]
- Sorted a: [4, 9]
- **Reordered pairs**: [(2,4), (8,9)]

#### R1.5: Build Main Chain
- S = [2] (first b value bâ‚)
- S = [2, 4, 9] (add all a values)

#### R1.6: Jacobsthal & Insert Remaining b's
- Remaining b values: [8] (only bâ‚‚)
- Jacobsthal for 1 element: [0, 1]
- Insertion order: [1] â†’ insert bâ‚‚ = 8

**Insert bâ‚‚ = 8 (paired with aâ‚‚ = 9):**
- S = [2, 4, 9]
- aâ‚‚ = 9 is at position 2
- Search [0 to 2]: binary search for 8 in [2, 4, 9]
- 8 > 4, 8 < 9 â†’ insert at position 2
- S = [2, 4, 8, 9]

#### R1.7: Return [2, 4, 8, 9]

### ðŸ“¤ RECURSION RETURNED: [2, 4, 8, 9]

---

## Step 5: Reorder Pairs According to Sorted 'a' Values
Rearrange the original pairs so their 'a' values are in sorted order:

| Original Pairs | Sorted 'a' | Reordered Pairs |
|----------------|------------|------------------|
| (6,9) (5,8) (3,4) (1,2) | [2,4,8,9] | (1,2) (3,4) (5,8) (6,9) |

**Sorted Pairs**: [(1,2), (3,4), (5,8), (6,9)]

---

## Step 6: Build Main Chain S
Start with bâ‚, then add all 'a' values:
- S = [bâ‚] = [1]
- S = [bâ‚, aâ‚, aâ‚‚, aâ‚ƒ, aâ‚„] = [1, 2, 4, 8, 9]

**Main Chain S**: [1, 2, 4, 8, 9]

---

## Step 7: Calculate Jacobsthal Sequence
For n = 3 remaining b values (bâ‚‚, bâ‚ƒ, bâ‚„ = 3, 5, 6):

Jacobsthal formula: J(k) = J(k-1) + 2Ã—J(k-2), where J(0)=0, J(1)=1

| k | J(k) | Calculation |
|---|------|-------------|
| 0 | 0    | base        |
| 1 | 1    | base        |
| 2 | 1    | 1 + 2Ã—0 = 1 |
| 3 | 3    | 1 + 2Ã—1 = 3 |
| 4 | 5    | 3 + 2Ã—1 = 5 |

**Jacobsthal Sequence**: [0, 1, 1, 3, 5]

---

## Step 8: Generate Insertion Order
Using Jacobsthal sequence, generate insertion order for indices 1, 2, 3:

Groups based on Jacobsthal:
- Jâ‚ƒ = 3, Jâ‚‚ = 1: Insert from 3 down to 2 (but we only have up to 3)
  â†’ Insert index 3, then 2
- Jâ‚‚ = 1, Jâ‚ = 1: Nothing (same value)
- Remaining: Insert index 1

**Insertion Order (indices)**: [3, 2, 1]
**Values to insert**: [bâ‚„=6, bâ‚ƒ=5, bâ‚‚=3]

---

## Step 9: Insert b Values Using Binary Search (Limited Range)

### Insert bâ‚„ = 6 (paired with aâ‚„ = 9)
- S = [1, 2, 4, 8, 9]
- aâ‚„ = 9 is at position 4
- **Search range**: [0, 4] (up to position of paired 'a')
- Binary search for 6 in [1, 2, 4, 8, 9]:
  - 6 > 4, 6 < 8
  - Insert at position 3
- S = [1, 2, 4, **6**, 8, 9]

### Insert bâ‚ƒ = 5 (paired with aâ‚ƒ = 8)
- S = [1, 2, 4, 6, 8, 9]
- aâ‚ƒ = 8 is at position 4 (after previous insertion)
- **Search range**: [0, 4]
- Binary search for 5 in [1, 2, 4, 6, 8]:
  - 5 > 4, 5 < 6
  - Insert at position 3
- S = [1, 2, 4, **5**, 6, 8, 9]

### Insert bâ‚‚ = 3 (paired with aâ‚‚ = 4)
- S = [1, 2, 4, 5, 6, 8, 9]
- aâ‚‚ = 4 is at position 2 (after previous insertions)
- **Search range**: [0, 2]
- Binary search for 3 in [1, 2, 4]:
  - 3 > 2, 3 < 4
  - Insert at position 2
- S = [1, 2, **3**, 4, 5, 6, 8, 9]

---

## Step 10: Insert Leftover
- S = [1, 2, 3, 4, 5, 6, 8, 9]
- Leftover = 7
- **Search range**: entire array [0, 8]
- Binary search for 7:
  - 7 > 6, 7 < 8
  - Insert at position 6
- S = [1, 2, 3, 4, 5, 6, **7**, 8, 9]

---

## Final Result
**Sorted Array**: [1, 2, 3, 4, 5, 6, 7, 8, 9] âœ“

---

## Recursion Tree Summary

```
fordJohnson([6,9,5,8,3,4,1,2,7])  â† Main call (depth 0)
â”‚
â”œâ”€ Pairs: [(6,9), (5,8), (3,4), (1,2)]
â”œâ”€ Extract a: [9, 8, 4, 2]
â”‚
â””â”€ fordJohnson([9,8,4,2])  â† Recursive call (depth 1)
   â”‚
   â”œâ”€ Pairs: [(8,9), (2,4)]
   â”œâ”€ Extract a: [9, 4]
   â”‚
   â””â”€ fordJohnson([9,4])  â† Recursive call (depth 2)
      â”‚
      â”œâ”€ Pairs: [(4,9)]
      â”œâ”€ Extract a: [9]
      â”œâ”€ Base case: [9] (only 1 element)
      â”‚
      â””â”€ Return [4, 9]  â† Depth 2 result
   
   â””â”€ Use [4,9] to build: [2, 4, 8, 9]
   â””â”€ Return [2, 4, 8, 9]  â† Depth 1 result

â””â”€ Use [2,4,8,9] to build final: [1,2,3,4,5,6,7,8,9]
```

---

## Summary
- **Total Comparisons**: ~20 (including recursive calls)
- **Recursion Depth**: 2 levels
- **Initial pairs**: 4
- **Recursive sort**: Goes 2 levels deep to sort 'a' values
- **Binary insertions**: 3 b-values + 1 leftover = 4 insertions in main level, plus insertions in recursive calls
- **Jacobsthal optimization**: Minimizes worst-case comparisons

---

## Key Insights
1. **TRUE Recursion**: The algorithm recursively sorts the 'a' values using Ford-Johnson itself
2. **Pairing at each level**: Each recursion level creates its own pairs
3. **Deep recursion**: For small arrays, may recurse 2-3 levels deep
4. **Bottom-up building**: Builds sorted arrays from the deepest recursion upward
5. **Limited binary search at each level**: Each level uses its own Jacobsthal sequence
