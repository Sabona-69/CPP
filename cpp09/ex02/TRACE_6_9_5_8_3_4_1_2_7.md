# Ford-Johnson Algorithm Trace for Input: 6 9 5 8 3 4 1 2 7

## Initial Array
Input: [6, 9, 5, 8, 3, 4, 1, 2, 7]
Size: 9 elements (odd)

---

## Step 1: Handle Odd Number
Since we have 9 elements (odd), save the last element for later:
- **Leftover**: 7
- **Working Array**: [6, 9, 5, 8, 3, 4, 1, 2]

---

## Step 2: Create Pairs (Compare and Sort Within Pairs)
Pair up adjacent elements, keeping larger as 'a' and smaller as 'b':

| Pair | Compare | Result (b, a) |
|------|---------|---------------|
| 1    | 6 vs 9  | (6, 9)        |
| 2    | 5 vs 8  | (5, 8)        |
| 3    | 3 vs 4  | (3, 4)        |
| 4    | 1 vs 2  | (1, 2)        |

**Pairs**: [(6,9), (5,8), (3,4), (1,2)]

---

## Step 3: Extract 'a' Values (Larger Elements)
From each pair, extract the larger value (a):
- **a values**: [9, 8, 4, 2]

---

## Step 4: 📥 RECURSION - Sort 'a' Values Using Ford-Johnson

### RECURSION LEVEL 1: Sort [9, 8, 4, 2]

#### R1.1: Create Pairs
- Compare 9 vs 8 → (8, 9)
- Compare 4 vs 2 → (2, 4)
- **Pairs**: [(8,9), (2,4)]

#### R1.2: Extract 'a' values
- **a values**: [9, 4]

#### R1.3: 📥 RECURSION - Sort [9, 4]

##### RECURSION LEVEL 2: Sort [9, 4]

###### R2.1: Create Pairs (only 2 elements)
- Compare 9 vs 4 → (4, 9)
- **Pairs**: [(4, 9)]

###### R2.2: Extract 'a' values
- **a values**: [9]

###### R2.3: Base Case
- Only 1 element, already sorted: [9]

###### R2.4: Build Main Chain
- S = [4] (first b)
- S = [4, 9] (add all a's)
- No more b values to insert
- **Return [4, 9]**

##### 📤 RECURSION RETURNED: [4, 9]

#### R1.4: Reorder pairs by sorted 'a' values
- Original: [(8,9), (2,4)]
- Sorted a: [4, 9]
- **Reordered pairs**: [(2,4), (8,9)]

#### R1.5: Build Main Chain
- S = [2] (first b value b₁)
- S = [2, 4, 9] (add all a values)

#### R1.6: Jacobsthal & Insert Remaining b's
- Remaining b values: [8] (only b₂)
- Jacobsthal for 1 element: [0, 1]
- Insertion order: [1] → insert b₂ = 8

**Insert b₂ = 8 (paired with a₂ = 9):**
- S = [2, 4, 9]
- a₂ = 9 is at position 2
- Search [0 to 2]: binary search for 8 in [2, 4, 9]
- 8 > 4, 8 < 9 → insert at position 2
- S = [2, 4, 8, 9]

#### R1.7: Return [2, 4, 8, 9]

### 📤 RECURSION RETURNED: [2, 4, 8, 9]

---

## Step 5: Reorder Pairs According to Sorted 'a' Values
Rearrange the original pairs so their 'a' values are in sorted order:

| Original Pairs | Sorted 'a' | Reordered Pairs |
|----------------|------------|------------------|
| (6,9) (5,8) (3,4) (1,2) | [2,4,8,9] | (1,2) (3,4) (5,8) (6,9) |

**Sorted Pairs**: [(1,2), (3,4), (5,8), (6,9)]

---

## Step 6: Build Main Chain S
Start with b₁, then add all 'a' values:
- S = [b₁] = [1]
- S = [b₁, a₁, a₂, a₃, a₄] = [1, 2, 4, 8, 9]

**Main Chain S**: [1, 2, 4, 8, 9]

---

## Step 7: Calculate Jacobsthal Sequence
For n = 3 remaining b values (b₂, b₃, b₄ = 3, 5, 6):

Jacobsthal formula: J(k) = J(k-1) + 2×J(k-2), where J(0)=0, J(1)=1

| k | J(k) | Calculation |
|---|------|-------------|
| 0 | 0    | base        |
| 1 | 1    | base        |
| 2 | 1    | 1 + 2×0 = 1 |
| 3 | 3    | 1 + 2×1 = 3 |
| 4 | 5    | 3 + 2×1 = 5 |

**Jacobsthal Sequence**: [0, 1, 1, 3, 5]

---

## Step 8: Generate Insertion Order
Using Jacobsthal sequence, generate insertion order for indices 1, 2, 3:

Groups based on Jacobsthal:
- J₃ = 3, J₂ = 1: Insert from 3 down to 2 (but we only have up to 3)
  → Insert index 3, then 2
- J₂ = 1, J₁ = 1: Nothing (same value)
- Remaining: Insert index 1

**Insertion Order (indices)**: [3, 2, 1]
**Values to insert**: [b₄=6, b₃=5, b₂=3]

---

## Step 9: Insert b Values Using Binary Search (Limited Range)

### Insert b₄ = 6 (paired with a₄ = 9)
- S = [1, 2, 4, 8, 9]
- a₄ = 9 is at position 4
- **Search range**: [0, 4] (up to position of paired 'a')
- Binary search for 6 in [1, 2, 4, 8, 9]:
  - 6 > 4, 6 < 8
  - Insert at position 3
- S = [1, 2, 4, **6**, 8, 9]

### Insert b₃ = 5 (paired with a₃ = 8)
- S = [1, 2, 4, 6, 8, 9]
- a₃ = 8 is at position 4 (after previous insertion)
- **Search range**: [0, 4]
- Binary search for 5 in [1, 2, 4, 6, 8]:
  - 5 > 4, 5 < 6
  - Insert at position 3
- S = [1, 2, 4, **5**, 6, 8, 9]

### Insert b₂ = 3 (paired with a₂ = 4)
- S = [1, 2, 4, 5, 6, 8, 9]
- a₂ = 4 is at position 2 (after previous insertions)
- **Search range**: [0, 2]
- Binary search for 3 in [1, 2, 4]:
  - 3 > 2, 3 < 4
  - Insert at position 2
- S = [1, 2, **3**, 4, 5, 6, 8, 9]

---

## Step 10: Insert Leftover
- S = [1, 2, 3, 4, 5, 6, 8, 9]
- Leftover = 7
- **Search range**: entire array [0, 8]
- Binary search for 7:
  - 7 > 6, 7 < 8
  - Insert at position 6
- S = [1, 2, 3, 4, 5, 6, **7**, 8, 9]

---

## Final Result
**Sorted Array**: [1, 2, 3, 4, 5, 6, 7, 8, 9] ✓

---

## Recursion Tree Summary

```
fordJohnson([6,9,5,8,3,4,1,2,7])  ← Main call (depth 0)
│
├─ Pairs: [(6,9), (5,8), (3,4), (1,2)]
├─ Extract a: [9, 8, 4, 2]
│
└─ fordJohnson([9,8,4,2])  ← Recursive call (depth 1)
   │
   ├─ Pairs: [(8,9), (2,4)]
   ├─ Extract a: [9, 4]
   │
   └─ fordJohnson([9,4])  ← Recursive call (depth 2)
      │
      ├─ Pairs: [(4,9)]
      ├─ Extract a: [9]
      ├─ Base case: [9] (only 1 element)
      │
      └─ Return [4, 9]  ← Depth 2 result
   
   └─ Use [4,9] to build: [2, 4, 8, 9]
   └─ Return [2, 4, 8, 9]  ← Depth 1 result

└─ Use [2,4,8,9] to build final: [1,2,3,4,5,6,7,8,9]
```

---

## Summary
- **Total Comparisons**: ~20 (including recursive calls)
- **Recursion Depth**: 2 levels
- **Initial pairs**: 4
- **Recursive sort**: Goes 2 levels deep to sort 'a' values
- **Binary insertions**: 3 b-values + 1 leftover = 4 insertions in main level, plus insertions in recursive calls
- **Jacobsthal optimization**: Minimizes worst-case comparisons

---

## Key Insights
1. **TRUE Recursion**: The algorithm recursively sorts the 'a' values using Ford-Johnson itself
2. **Pairing at each level**: Each recursion level creates its own pairs
3. **Deep recursion**: For small arrays, may recurse 2-3 levels deep
4. **Bottom-up building**: Builds sorted arrays from the deepest recursion upward
5. **Limited binary search at each level**: Each level uses its own Jacobsthal sequence
